
import bpy
import math

# ==========================================================
# === This script was auto-generated by your LCA tool ===
# === Model: Building-A
# ==========================================================

# --- Parameters (Injected from your script) ---
L = 48.0
W = 12.0
H_STORY = 3.5
N_STORIES = 4
TOTAL_H = 14.0

NUM_COLS_X = 9
NUM_COLS_Y = 3
X_SPACING = 6.0
Y_SPACING = 6.0
X_START = -24.0
Y_START = -6.0

WWR_N = 0.4
WWR_S = 0.7
WWR_E = 0.0
WWR_W = 0.0

N_CORES = 1
BUILDING_USE = "R"
CORRIDOR_POS = "N" # NEW
CORRIDOR_WIDTH = 1.8

# --- Cosmetic Parameters ---
SLAB_THICKNESS = 0.3
WALL_THICKNESS = 0.3
COL_RADIUS = 0.25
BEAM_HEIGHT = 0.4
BEAM_WIDTH = 0.3
CORE_DIM = 5.0
PARTITION_THICKNESS = 0.15
BATH_MODULE_DIM = 2.0 # 2x2m bathroom
    
# --- Helper Functions ---

def clear_scene():
    # Clear all mesh objects from the scene.
    bpy.ops.object.select_all(action='DESELECT')
    bpy.ops.object.select_by_type(type='MESH')
    bpy.ops.object.delete()
    
    for collection in bpy.data.collections:
        if not collection.name == "Scene Collection":
            bpy.data.collections.remove(collection)

def create_collection(name):
    # Create a new collection and link it to the scene.
    if name in bpy.data.collections:
        return bpy.data.collections[name]
    new_coll = bpy.data.collections.new(name)
    bpy.context.scene.collection.children.link(new_coll)
    return new_coll

def add_to_collection(obj, coll):
    # Move an object to a collection.
    for c in obj.users_collection:
        c.objects.unlink(obj)
    coll.objects.link(obj)

def create_box(name, location, dimensions, coll):
    # Helper to create a simple box.
    bpy.ops.mesh.primitive_cube_add(size=1, location=location, enter_editmode=False)
    obj = bpy.context.active_object
    obj.name = name
    obj.dimensions = dimensions
    bpy.ops.object.transform_apply(location=False, rotation=False, scale=True)
    add_to_collection(obj, coll)
    return obj

def create_cylinder(name, location, radius, depth, coll):
    # Helper to create a simple cylinder.
    bpy.ops.mesh.primitive_cylinder_add(
        radius=radius, 
        depth=depth, 
        location=location,
        vertices=16
    )
    obj = bpy.context.active_object
    obj.name = name
    add_to_collection(obj, coll)
    return obj

def apply_boolean(target, cutter, operation='DIFFERENCE'):
    # Apply a boolean modifier.
    mod = target.modifiers.new(name=f"Bool_{cutter.name}", type='BOOLEAN')
    mod.object = cutter
    mod.operation = operation
    cutter.display_type = 'WIRE' 
    cutter.hide_render = True
    return mod

# --- Main Script ---

def build_model():
    print("Building parametric model in Blender...")
    
    # --- 1. Setup Collections ---
    coll_slabs = create_collection("Slabs")
    coll_cols = create_collection("Columns")
    coll_beams = create_collection("Beams")
    coll_facades = create_collection("Facades")
    coll_cores = create_collection("Cores")
    coll_partitions = create_collection("Internal_Partitions")
    coll_cutters = create_collection("Cutters (Hide Me)")

    # --- 2. Create Slabs ---
    for i in range(N_STORIES + 1):
        z_pos = i * H_STORY
        loc = (0, 0, z_pos - (SLAB_THICKNESS / 2.0))
        name = f"Slab_L{i}"
        if i == 0: name = "Ground_Slab"
        if i == N_STORIES: name = "Roof_Slab"
        create_box(name, loc, (L, W, SLAB_THICKNESS), coll_slabs)

    # --- 3. Create Columns ---
    if NUM_COLS_X > 0 and NUM_COLS_Y > 0:
        for i in range(NUM_COLS_X):
            x = X_START + i * X_SPACING
            for j in range(NUM_COLS_Y):
                y = Y_START + j * Y_SPACING
                loc = (x, y, TOTAL_H / 2.0)
                name = f"Column_{i}_{j}"
                create_cylinder(name, loc, COL_RADIUS, TOTAL_H, coll_cols)

    # --- 4. Create Beams ---
    for k in range(N_STORIES):
        level = k + 1
        z_pos = (level * H_STORY) - SLAB_THICKNESS - (BEAM_HEIGHT / 2.0)
        
        if NUM_COLS_Y > 0:
            for j in range(NUM_COLS_Y):
                y = Y_START + j * Y_SPACING
                loc = (0, y, z_pos)
                name = f"Beam_X_L{level}_{j}"
                create_box(name, loc, (L, BEAM_WIDTH, BEAM_HEIGHT), coll_beams)

        if NUM_COLS_X > 0:
            for i in range(NUM_COLS_X):
                x = X_START + i * X_SPACING
                loc = (x, 0, z_pos)
                name = f"Beam_Y_L{level}_{j}"
                create_box(name, loc, (BEAM_WIDTH, W, BEAM_HEIGHT), coll_beams)

    # --- 5. Create Facades (Walls and Windows) per Story ---
    for i in range(N_STORIES):
        z_bottom = i * H_STORY
        z_top = (i + 1) * H_STORY - SLAB_THICKNESS - BEAM_HEIGHT
        
        panel_height = z_top - z_bottom
        if panel_height <= 0:
            print(f"Skipping wall generation for level {i}, panel height is zero or negative.")
            continue
            
        z_center = z_bottom + (panel_height / 2.0)

        wall_n = create_box(f"Wall_North_L{i}", (0, W/2, z_center), (L, WALL_THICKNESS, panel_height), coll_facades)
        wall_s = create_box(f"Wall_South_L{i}", (0, -W/2, z_center), (L, WALL_THICKNESS, panel_height), coll_facades)
        wall_e = create_box(f"Wall_East_L{i}", (L/2, 0, z_center), (WALL_THICKNESS, W, panel_height), coll_facades)
        wall_w = create_box(f"Wall_West_L{i}", (-L/2, 0, z_center), (WALL_THICKNESS, W, panel_height), coll_facades)

        window_height = panel_height * 0.8
        window_z_pos = z_center 
        
        bay_width_x = X_SPACING
        if bay_width_x > 0 and (NUM_COLS_X - 1) > 0:
            if WWR_N > 0:
                window_width = bay_width_x * math.sqrt(WWR_N)
                window_width = min(window_width, bay_width_x * 0.9) 
                
                for j in range(NUM_COLS_X - 1):
                    bay_center_x = (X_START + j * X_SPACING) + (bay_width_x / 2.0)
                    loc_n = (bay_center_x, W/2, window_z_pos)
                    cutter_n = create_box(f"Cutter_N_L{i}_B{j}", loc_n, (window_width, WALL_THICKNESS*2, window_height), coll_cutters)
                    apply_boolean(wall_n, cutter_n)

            if WWR_S > 0:
                window_width = bay_width_x * math.sqrt(WWR_S)
                window_width = min(window_width, bay_width_x * 0.9)
                
                for j in range(NUM_COLS_X - 1):
                    bay_center_x = (X_START + j * X_SPACING) + (bay_width_x / 2.0)
                    loc_s = (bay_center_x, -W/2, window_z_pos)
                    cutter_s = create_box(f"Cutter_S_L{i}_B{j}", loc_s, (window_width, WALL_THICKNESS*2, window_height), coll_cutters)
                    apply_boolean(wall_s, cutter_s)

        bay_width_y = Y_SPACING
        if bay_width_y > 0 and (NUM_COLS_Y - 1) > 0:
            if WWR_E > 0:
                window_width = bay_width_y * math.sqrt(WWR_E)
                window_width = min(window_width, bay_width_y * 0.9)

                for j in range(NUM_COLS_Y - 1):
                    bay_center_y = (Y_START + j * Y_SPACING) + (bay_width_y / 2.0)
                    loc_e = (L/2, bay_center_y, window_z_pos)
                    cutter_e = create_box(f"Cutter_E_L{i}_B{j}", loc_e, (WALL_THICKNESS*2, window_width, window_height), coll_cutters)
                    apply_boolean(wall_e, cutter_e)

            if WWR_W > 0:
                window_width = bay_width_y * math.sqrt(WWR_W)
                window_width = min(window_width, bay_width_y * 0.9)

                for j in range(NUM_COLS_Y - 1):
                    bay_center_y = (Y_START + j * Y_SPACING) + (bay_width_y / 2.0)
                    loc_w = (-L/2, bay_center_y, window_z_pos)
                    cutter_w = create_box(f"Cutter_W_L{i}_B{j}", loc_w, (WALL_THICKNESS*2, window_width, window_height), coll_cutters)
                    apply_boolean(wall_w, cutter_w)

    # --- 6. Create Vertical Cores ---
    if N_CORES > 0:
        total_core_span = (N_CORES * CORE_DIM) + (N_CORES - 1) * 1.0
        current_core_x = -total_core_span / 2.0 + (CORE_DIM / 2.0)
        
        # Core Y position depends on corridor
        if CORRIDOR_POS == 'S':
            # Place adjacent to South facade
            core_y = (-W / 2.0) + WALL_THICKNESS + (CORE_DIM / 2.0)
        else:
            # Place adjacent to North facade (for 'M' and 'N' layouts)
            core_y = (W / 2.0) - WALL_THICKNESS - (CORE_DIM / 2.0)

        for i in range(N_CORES):
            loc = (current_core_x, core_y, TOTAL_H / 2.0)
            name = f"Core_{i+1}"
            create_box(name, loc, (CORE_DIM, CORE_DIM, TOTAL_H), coll_cores)
            current_core_x += CORE_DIM + 1.0

    # --- 7. Create Internal Partitions (New Logic) ---
    if CORRIDOR_WIDTH > 0:
        print(f"Generating internal partitions for {BUILDING_USE} use ({CORRIDOR_POS} layout).")
        
        # Define parameters based on building use
        unit_size_map = {'R': 71.5, 'C': 50, 'O': 80}
        bathrooms_per_unit_map = {'R': 1, 'C': 2, 'O': 2}
        
        unit_size = unit_size_map.get(BUILDING_USE, 71.5)
        baths_per_unit = bathrooms_per_unit_map.get(BUILDING_USE, 1)

        # Calculate unit layout
        rentable_area_per_floor = (L * W) - (L * CORRIDOR_WIDTH)
        if rentable_area_per_floor < 0: rentable_area_per_floor = 0
        
        num_units_per_floor = math.floor(rentable_area_per_floor / unit_size) if unit_size > 0 else 0
        
        for i in range(N_STORIES):
            # Partitions go from slab to bottom of next slab
            z_bottom = i * H_STORY
            panel_height = H_STORY - SLAB_THICKNESS 
            z_center = z_bottom + (panel_height / 2.0)
            
            if panel_height <= 0:
                continue # Skip floor if height is invalid

            # --- Branching layout logic ---
            
            if CORRIDOR_POS == 'M':
                # --- Double-Loaded Corridor (Center) ---
                corridor_y_n = CORRIDOR_WIDTH / 2.0
                corridor_y_s = -CORRIDOR_WIDTH / 2.0
                
                create_box(f"Corridor_N_L{i}", (0, corridor_y_n, z_center), (L, PARTITION_THICKNESS, panel_height), coll_partitions)
                create_box(f"Corridor_S_L{i}", (0, corridor_y_s, z_center), (L, PARTITION_THICKNESS, panel_height), coll_partitions)

                num_units_per_side = math.floor(num_units_per_floor / 2)
                unit_depth = (W - CORRIDOR_WIDTH) / 2.0 - PARTITION_THICKNESS
                unit_width = L / num_units_per_side if num_units_per_side > 0 else 0

                if unit_width > 0:
                    # Create the demising walls (between units)
                    for j in range(1, num_units_per_side): # Loop from 1 to N-1
                        x_pos = X_START + j * unit_width
                        
                        # North side demising wall
                        y_pos_n = corridor_y_n + (unit_depth / 2.0)
                        create_box(f"Partition_N_L{i}_{j}", (x_pos, y_pos_n, z_center), (PARTITION_THICKNESS, unit_depth, panel_height), coll_partitions)
                        
                        # South side demising wall
                        y_pos_s = corridor_y_s - (unit_depth / 2.0)
                        create_box(f"Partition_S_L{i}_{j}", (x_pos, y_pos_s, z_center), (PARTITION_THICKNESS, unit_depth, panel_height), coll_partitions)

                    # Create bathroom modules
                    for j in range(num_units_per_side):
                        unit_start_x = X_START + j * unit_width
                        bath_x = unit_start_x + (BATH_MODULE_DIM / 2.0) + PARTITION_THICKNESS
                        
                        # North side bathrooms
                        bath_y_n = corridor_y_n + (BATH_MODULE_DIM / 2.0) + PARTITION_THICKNESS
                        create_box(f"Bath_N_L{i}_{j}_1", (bath_x, bath_y_n, z_center), (BATH_MODULE_DIM, BATH_MODULE_DIM, panel_height), coll_partitions)
                        if baths_per_unit == 2:
                            bath_x_2 = bath_x + BATH_MODULE_DIM + 0.1
                            create_box(f"Bath_N_L{i}_{j}_2", (bath_x_2, bath_y_n, z_center), (BATH_MODULE_DIM, BATH_MODULE_DIM, panel_height), coll_partitions)

                        # South side bathrooms
                        bath_y_s = corridor_y_s - (BATH_MODULE_DIM / 2.0) - PARTITION_THICKNESS
                        create_box(f"Bath_S_L{i}_{j}_1", (bath_x, bath_y_s, z_center), (BATH_MODULE_DIM, BATH_MODULE_DIM, panel_height), coll_partitions)
                        if baths_per_unit == 2:
                            bath_x_2 = bath_x + BATH_MODULE_DIM + 0.1
                            create_box(f"Bath_S_L{i}_{j}_2", (bath_x_2, bath_y_s, z_center), (BATH_MODULE_DIM, BATH_MODULE_DIM, panel_height), coll_partitions)

            else:
                # --- Single-Loaded Corridor (North or South) ---
                num_units_on_side = num_units_per_floor
                # Depth from partition wall to *inside* of facade wall
                unit_depth = W - CORRIDOR_WIDTH - WALL_THICKNESS - PARTITION_THICKNESS 
                unit_width = L / num_units_on_side if num_units_on_side > 0 else 0
                
                corridor_partition_y = 0
                unit_y_pos = 0
                bath_y = 0
                
                if CORRIDOR_POS == 'N':
                    # Corridor at North, units face South
                    # The ONE partition wall is south of the corridor
                    corridor_partition_y = (W / 2.0) - WALL_THICKNESS - CORRIDOR_WIDTH
                    # Units are south of that
                    unit_y_pos = corridor_partition_y - (unit_depth / 2.0)
                    # Bathrooms are just south of the partition
                    bath_y = corridor_partition_y - (BATH_MODULE_DIM / 2.0) - PARTITION_THICKNESS
                
                elif CORRIDOR_POS == 'S':
                    # Corridor at South, units face North
                    # The ONE partition wall is north of the corridor
                    corridor_partition_y = (-W / 2.0) + WALL_THICKNESS + CORRIDOR_WIDTH
                    # Units are north of that
                    unit_y_pos = corridor_partition_y + (unit_depth / 2.0)
                    # Bathrooms are just north of the partition
                    bath_y = corridor_partition_y + (BATH_MODULE_DIM / 2.0) + PARTITION_THICKNESS

                # Create the *one* corridor wall
                create_box(f"Corridor_Wall_L{i}", (0, corridor_partition_y, z_center), (L, PARTITION_THICKNESS, panel_height), coll_partitions)

                if unit_width > 0 and unit_depth > 0:
                    # Create demising walls (one side only)
                    for j in range(1, num_units_on_side): # Loop from 1 to N-1
                        x_pos = X_START + j * unit_width
                        create_box(f"Partition_L{i}_{j}", (x_pos, unit_y_pos, z_center), (PARTITION_THICKNESS, unit_depth, panel_height), coll_partitions)
                    
                    # Create bathrooms (one side only)
                    for j in range(num_units_on_side):
                        unit_start_x = X_START + j * unit_width
                        bath_x = unit_start_x + (BATH_MODULE_DIM / 2.0) + PARTITION_THICKNESS
                        
                        create_box(f"Bath_L{i}_{j}_1", (bath_x, bath_y, z_center), (BATH_MODULE_DIM, BATH_MODULE_DIM, panel_height), coll_partitions)
                        if baths_per_unit == 2:
                            bath_x_2 = bath_x + BATH_MODULE_DIM + 0.1
                            create_box(f"Bath_L{i}_{j}_2", (bath_x_2, bath_y, z_center), (BATH_MODULE_DIM, BATH_MODULE_DIM, panel_height), coll_partitions)

    print("Blender model generation complete.")


# --- Run the script ---
clear_scene()
build_model()
bpy.ops.object.select_all(action='DESELECT')

